\section{Desarrollo}

\subsection{Descripción general de la arquitectura}
La arquitectura implementada se compone de cinco bloques principales:
\begin{enumerate}
    \item \textbf{ALU}: bloque combinacional parametrizable que ejecuta las operaciones definidas por \texttt{i\_op}.
    \item \textbf{TOP}: bloque secuencial que registra operandos A/B y el código de operación a partir de los switches y botones de la Basys 3; además enruta resultados a LEDs y display.
    \item \textbf{Hex\_to\_sseg}: decodifica un nibble hexadecimal (0--F) a segmentos (bajo activo).
    \item \textbf{SevenSeg\_hex}: multiplexa cuatro dígitos, selecciona el nibble a mostrar y controla \texttt{o\_an}/\texttt{o\_seg}.
    \item \textbf{Testbench}: banco de prueba autocontenible que aplica estímulos representativos y observa salidas.
\end{enumerate}

\subsection{ALU: consideraciones de diseño}
\paragraph{Interfaz y parámetros.}
La ALU recibe dos operandos \texttt{signed} de \texttt{NB\_DATA} bits y un código de operación de \texttt{NB\_OP} bits. La salida \texttt{o\_result} es \texttt{signed} y del mismo ancho que los operandos.

\paragraph{Ruta de datos interna.}
Se utiliza un registro interno \texttt{r\_result} de \texttt{NB\_DATA+1} bits para computar resultados de suma/resta con un bit extra (posible acarreo/overflow). Finalmente se asigna a \texttt{o\_result} truncando a \texttt{NB\_DATA} bits (sin saturación).

\paragraph{Operaciones de corrimiento.}
\begin{itemize}
    \item \textbf{SRA}: \verb|i_data_a >>> i_data_b|. 
    Al ser \verb|i_data_a| \texttt{signed}, el operador \verb|>>>| replica el bit de signo. 

    \item \textbf{SRL}: se fuerza lógico enmascarando el corrimiento:
    \lstinline|$unsigned(i_data_a) >> i_data_b[$clog2(NB_DATA)-1:0]|.
\end{itemize}

\begin{sloppypar}
\textit{Recomendación de robustez:} también enmascarar el corrimiento en SRA con \texttt{i\_data\_b[\$clog2(NB\_DATA)-1:0]} para hacer explícito el límite del ancho, evitando dependencias de implementación.
\end{sloppypar}

\paragraph{Estilo de codificación.}
El bloque es combinacional (\texttt{always @(*)}) con asignaciones bloqueantes para la lógica interna; las señales de salida se asignan por \texttt{assign}. Este estilo evita \textit{latches} y facilita el mapeo a LUTs/sumadores del FPGA.

\subsection{TOP: captura de entradas y ruteo de salidas}
\paragraph{Captura de operandos y operación.}
\begin{itemize}
    \item \textbf{Reset}: síncrono con \texttt{i\_clk}; limpia registros \texttt{data\_a}, \texttt{data\_b}, \texttt{op}.
    \item \textbf{Botones}: al detectar \texttt{i\_btn\_a}, \texttt{i\_btn\_b}, \texttt{i\_btn\_op} se capturan respectivamente \texttt{i\_sw\_data} (operandos) y \texttt{i\_sw\_data[NB\_OP-1:0]} (operación).
    \item \textbf{Nota}: en hardware real, los botones \textit{rebotan}. Este diseño funcional no incluye \textit{debounce}; para robustez en placa se recomienda añadir sincronización doble y filtro (p.ej., contador temporal).
\end{itemize}

\paragraph{Visualización en LEDs y display.}
\begin{itemize}
    \item \texttt{o\_led\_now} refleja en tiempo real \texttt{i\_sw\_data} (útil para cargar operandos/códigos).
    \item \texttt{o\_led\_res} muestra el resultado de la ALU.
    \item \textbf{Display 7-seg}: \texttt{disp\_val = \{8'h00, alu\_result[7:4], alu\_result[3:0]\}} muestra el resultado en dos dígitos hex; los dos dígitos altos quedan en cero. El punto decimal (\texttt{o\_dp}) permanece apagado.
\end{itemize}

\subsection{Módulos de visualización}
\paragraph{\texttt{hex\_to\_sseg}.}
Tabla de verdad que mapea un nibble (0--F) a segmentos \textbf{bajo activo}. La Basys 3 utiliza ánodos comunes por dígito y cátodos compartidos para segmentos, por eso la codificación de 0 es \texttt{7'b1000000} (todos los segmentos activos menos el punto).

\paragraph{\texttt{sevenseg\_hex}.}
\begin{itemize}
    \item \textbf{Divisor}: contador de 16 bits a 100\,MHz. Con \texttt{sel = div[15:14]} se recorre cada dígito a $\sim$6.1\,kHz y cada dígito se refresca a $\sim$1.5\,kHz (sin parpadeo).
    \item \textbf{Selección de nibble}: según \texttt{sel} se elige el nibble correspondiente de \texttt{i\_value}.
    \item \textbf{Anodos}: \texttt{o\_an} es bajo activo; se activa sólo el dígito seleccionado.
\end{itemize}

\subsection{Banco de pruebas (\textit{testbench})}
El \texttt{testbench} (\texttt{tb\_top\_alu}) instancia el \texttt{top}, genera reloj a 100\,MHz (\texttt{always \#5 clk = \string~clk}) y define \textbf{tareas} para cargar operandos y operación:
\begin{itemize}
    \item \texttt{load\_A(v)}: coloca \texttt{v} en \texttt{sw}, pulsa \texttt{btn\_a}.
    \item \texttt{load\_B(v)}: análogo para \texttt{btn\_b}.
    \item \texttt{load\_OP(v)}: carga \texttt{v} (6 bits) en \texttt{sw} justificado a la derecha, pulsa \texttt{btn\_op}.
\end{itemize}
Secuencia de prueba incluida:
\begin{enumerate}
    \item Reset.
    \item $A = -5$ (\texttt{0xFB}), $B = 3$.
    \item \textbf{ADD} $\Rightarrow$ \texttt{0xFE} ($-2$).
    \item \textbf{SUB} $\Rightarrow$ \texttt{0xF8} ($-8$).
    \item Cargar $B=1$ para corrimientos; \textbf{SRA}($A,1$) $\Rightarrow$ \texttt{0xFD} ($-3$).
    \item \textbf{SRL}($A,1$) $\Rightarrow$ \texttt{0x7D} ($125$).
    \item \textbf{NOR}($A,1$) $\Rightarrow$ \texttt{0x04}$^\ast$.
\end{enumerate}
\noindent\textit{$^\ast$} NOR($0xFB$, $0x01$): $\sim(1111\,1011 \;|\; 0000\,0001)=0000\,0100$.

\subsection{Integración con la placa Basys 3 (resumen)}
La integración física se realiza mediante el archivo de \textit{constraints} (\texttt{.xdc}) asignando:
\begin{itemize}
    \item \textbf{Reloj 100\,MHz}: \texttt{i\_clk} (W5).
    \item \textbf{Switches}: \texttt{i\_sw\_data[7:0]}.
    \item \textbf{Botones}: \texttt{i\_btn\_a}, \texttt{i\_btn\_b}, \texttt{i\_btn\_op}.
    \item \textbf{LEDs}: \texttt{o\_led\_now[7:0]}, \texttt{o\_led\_res[7:0]}.
    \item \textbf{7 segmentos}: \texttt{o\_seg[6:0]}, \texttt{o\_an[3:0]} (bajo activo).
\end{itemize}
\textit{Nota:} En el repositorio se incluye el \texttt{.xdc} correspondiente a la Basys 3 con las líneas relevantes descomentadas y renombradas.
